"""
https://proglib.io/p/slozhnost-algoritmov-i-operaciy-na-primere-python-2020-11-03
"Сложность алгоритмов и операций на примере Python.html"

«O» большое служит обозначением временной сложности операций алгоритма. Она показывает, сколько времени потребуется
алгоритму для вычисления требуемой операции.
На письме временная сложность алгоритма обозначается как O(n), где n — размер входной коллекции.

O(1)
Обозначение константной временной сложности. Независимо от размера коллекции, время, необходимое для выполнения
операции, константно.

O(log n)
Обозначение логарифмической временной сложности. В этом случае когда размер коллекции увеличивается, время,
необходимое для выполнения операции, логарифмически увеличивается.

O(n)
Обозначение линейной временной сложности. Время, необходимое для выполнения операции, прямо и линейно пропорционально
количеству элементов в коллекции.

O(n log n)
Обозначение квазилинейной временной сложности. Скорость выполнения операции является квазилинейной функцией числа
элементов в коллекции.

O(n^2)
Обозначение квадратичной временной сложности. Время, необходимое для выполнения операции, пропорционально квадрату
элементов в коллекции.

O(n!)
Обозначение факториальной временной сложности. Каждая операция требует вычисления всех перестановок коллекции,
следовательно, требуемое время выполнения операции является факториалом размера входной коллекции.
"""

"""
Благоприятные, средние и худшие случаи
При вычислении временной сложности операции можно получить сложность на основе благоприятного, среднего или худшего 
случая.

Благоприятный случай. Как следует из названия, это сценарий, когда структуры данных и элементы в коллекции вместе с 
параметрами находятся в оптимальном состоянии. Например, мы хотим найти элемент в коллекции. Если этот элемент 
оказывается первым элементом коллекции, то это лучший сценарий для операции.

Средний случай. Определяем сложность на основе распределения значений входных данных.

Худший случай. Структуры данных и элементы в коллекции вместе с параметрами находятся в наиболее неоптимальном 
состоянии. Например, худший случай для операции, которой требуется найти элемент в большой коллекции в виде списка — 
когда искомый элемент находится в самом конце, а алгоритм перебирает коллекцию с самого начала.
"""

"""
Коллекции Python и их временная сложность - 

* Список (list):
Вставка: O(n).
Получение элемента: O(1).
Удаление элемента: O(n).
Проход: O(n).
Получение длины: O(1)

* Множество (set)
Проверить наличие элемента в множестве: O(1).
Отличие множества A от B: O(длина A).
Пересечение множеств A и B: O(минимальная длина A или B).
Объединение множеств A и B: O(N) , где N это длина (A) + длина (B).

* Словарь (dict)
Получение элемента: O(1).
Установка элемента: O(1).
Удаление элемента: O(1).
Проход по словарю: O(n).
"""

"""



"""
